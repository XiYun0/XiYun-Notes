# 4种创建线程的方式

```r
基础Thread
实现Runnable
实现Callable
线程池
```

首先呢，Thread 类本质上是实现了 Runnable 接口，代表一个线程的实例。所以我们可以编写一个类，`继承Thread类`，或者直接`实现Runnable接口`，然后再重写下run方法就行了。启动线程的方式就是调用类里边的 start方法。start()方法是一个 native 方法，它的作用就是启动线程，线程会去执行 run()方法中的代码。

还有就是`实现 Callable 接口`，这个接口相当于是Runnable接口的增强版，他的执行代码的方法不是run方法了，是call方法，这个call方法可以有返回值，我们可以创建一个 FutureTask 类的实例对象，通过他的get()方法得到执行结果，不过这里定的执行结果需要跟FutureTask的泛型一致才行，并且call方法还可以抛出异常，通过这些，我们就能很明确的知道线程内部的执行状态。

还有就是通过`线程池`来实现，线程池就是事先将多个线程对象放到一个容器中，当使用的时候就不用 new 线程而是直接去池中拿线程即可，节省了开辟子线程的时间，提高的代码执行效率。 一般创建线程池的话，都是使用个的Executors 类中提供的创建线程池的静态方法。他可以创建4种线程池，有

FixedThreadPool，创建固定大小的线程池，比如线程池容量是10，最多可以同时执行10个线程。

CachedThreadPool，创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于JVM能够创建的最大线程大小，当然线程池里的线程是可以复用的，但是如果在高并发的情况下，这个线程池在会导致运行时内存溢出问题

ScheduledThreadPool，创建一个定时执行的线程池，里边提供了两个方法，FixRate和fixDelay，fixRate就是以固定时间周期执行任务，不管上一个线程是否执行完，fixDelay的话就是以固定的延迟执行任务，就是在上一个任务执行完成之后，延迟一定时间执行。

SingleThreadExecutor，创建一个单线程的线程池，这个线程池同时只能执行一个线程，可以保证线程按顺序执行，保证数据安全。



execute和submit的区别在于，前者没有返回值，只有执行任务。

```
区别：
1、2不能得到返回值。3可以获取返回值
1、2、3都不能控制资源
4可以控制资源，性能稳定。如果有100万个请求进来，每来一个请求就要开启一个线程，很快就会资源耗尽。任何一个高并发系统都是求稳为主！
```

