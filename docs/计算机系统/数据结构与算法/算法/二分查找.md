





# 二分查找

> 排序数组中的搜索问题，首先想到 **二分法** 解决！

## 练习

### [剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/5874p1/)

统计一个数字在排序数组中出现的次数。

 

示例 1:

```
输入: nums = [5,7,7,8,8,10], target = 8
输出: 2
```

示例 2:

```
输入: nums = [5,7,7,8,8,10], target = 6
输出: 0
```


限制：

`0 <= 数组长度 <= 50000`

注意：本题与主站 34 题相同（仅返回值不同）：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/

题解：

> 需要主要的是，边界处，是往左边二分，还是往右边二分

```java
```



### [剑指 Offer 53 - II. 0～n-1 中缺失的数字](https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/58iqo5/)

一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

示例 1:

```
输入: [0,1,3]
输出: 2
```

示例 2:

```
输入: [0,1,2,3,4,5,6,7,9]
输出: 8
```


限制：

`1 <= 数组长度 <= 10000`

题解：

> 题目条件，0~n-1，如果按照顺序来，数组的下标与下标对应的元素应该是相等的。
>
> 那么应该分左子数组和右子数组，前者nums[i] == i
>
> 用二分查找

```java
class Solution {
    public int missingNumber(int[] nums) {
        int i = 0, j = nums.length - 1;
        while(i <= j){
            int m = (i + j) / 2;
            if(nums[m] == m){
                i = m + 1;
            }else{
                j = m - 1;
            }
        }
        return i;
    }
}
```

