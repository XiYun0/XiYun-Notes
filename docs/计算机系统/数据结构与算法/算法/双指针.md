# 双指针

## 特点

```
两个指针解决一道题，是一种技巧！
```



| 类型       | 描述                                             | 适合场景 | 时间复杂度 |
| ---------- | ------------------------------------------------ | -------- | ---------- |
| 普通双指针 | 两个指针有时往同一个方向移动，有时往相反方向移动 |          |            |
| 对撞双指针 | 两个指针面对面移动，比如一个在头，一个在尾       | 有序数组 | O(N)       |
| 快慢双指针 | 慢指针 + 快指针                                  | 环形链表 |            |



### 快慢双指针

![image-20210513092151961](images/image-20210513092151961.png)

## 练习

### [剑指 Offer 18. 删除链表的节点](https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/505fc7/)

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

注意：此题对比原题有改动

示例 1:

```
输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
```

示例 2:

```
输入: head = [4,5,1,9], val = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.
```


说明：

- 题目保证链表中节点的值互不相同
- 若使用 C 或 C++ 语言，你不需要 `free` 或 `delete` 被删除的节点

题解：

> `快慢双指针`，如果head的val刚好就说要找到，那么丢掉头结点，返回head.next
>
> 如果不是，就用到pre和cur指针，pre负责记住cur。pre慢，cur快。cur会一直遍历移动，判断是否要删除。
>
> 当找到对应的val之后，那么让pre.next指向cur.next，也就是扔掉了cur这个节点

```java
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        if(head.val == val) return head.next;
        ListNode pre = head, cur = head.next;
        while(cur != null && cur.val != val) {
            pre = cur;
            cur = cur.next;
        }
        if(cur.val == val) pre.next = cur.next;
        return head;
    }
}
```

### [剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/5v8a6t/)

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

示例：

```
输入：nums = [1,2,3,4]
输出：[1,3,2,4] 
注：[3,1,2,4] 也是正确的答案之一。
```


提示：

1. `0 <= nums.length <= 50000`
2. `1 <= nums[i] <= 10000`

题解：

> 对撞双指针，一个找奇数，一个找偶数。当两个指针重合的时候，跳出循环。
>
> 对于`i`，他是负责奇数的，如果现在找到的是偶数，那么就等`j`那边出现奇数，准备和他调换吧！如果现在是奇数，那么往后遍历。

 $ x\&1 $ 位运算 `等价于` $x \% 2 $ 取余运算，即皆可用于判断数字奇偶性。

```java
class Solution {
    public int[] exchange(int[] nums) {
        int i = 0, j = nums.length - 1, tmp;
        while(i < j){
            while(i < j && (nums[i] & 1) == 1){
                i++;
            }
            while(i < j && (nums[j] & 1) == 0){
                j--;
            }
            tmp = nums[i];
            nums[i] = nums[j];
            nums[j] = tmp;
        }
        return nums;
    }
}
```



### [剑指 Offer 22. 链表中倒数第 k 个节点](https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/58tl52/)

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。

例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 `1、2、3、4、5、6`。这个链表的倒数第` 3` 个节点是值为` 4 `的节点。

示例：

```
给定一个链表: 1->2->3->4->5, 和 k = 2.

返回链表 4->5.
```



### 剑指 Offer 57. 和为 s 的两个数字

输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。

示例 1：

```
输入：nums = [2,7,11,15], target = 9
输出：[2,7] 或者 [7,2]
```

示例 2：

```
输入：nums = [10,26,30,31,47,60], target = 40
输出：[10,30] 或者 [30,10]
```


限制：

- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^6`

题解：

> 可以使用HashMap，时间复杂度为O(N)
>
> 使用对撞双指针，本质上就是二分查找法。

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int i = 0, j = nums.length - 1;
        while(i < j){
            int s = nums[i] + nums[j];
            if(s ==target){
                return new int[]{nums[i],nums[j]};
            }else if(s > target){
                j--;
            }else{
                i++;
            }
        }
        return new int[0];
    }
}
```



### LeetCode141

### LeeCode881