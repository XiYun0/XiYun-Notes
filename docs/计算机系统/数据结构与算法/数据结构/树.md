# 树

![image-20210512155420871](images/image-20210512155420871.png)

```markdown
节点：除了根节点和叶子节点外的节点
根节点：第一个开始的节点
叶子节点：最底层的节点，没有孩子
```

![image-20210512155523518](images/image-20210512155523518.png)

```markdown
深度：从上往下计算
高度：从下往上计算
层： 从上往下计算。1开始
```

## 二叉树

![image-20210512155805190](images/image-20210512155805190.png)

![image-20210512160157641](images/image-20210512160157641.png)

> 补充：
>
> - 满二叉树叶子节点必须在同一层。
>
> - 满二叉树一定是完全二叉树，但是完成二叉树不一定是满二叉树

二叉树遍历：

```markdown
1. 前序遍历：根左右
2. 中序遍历：左根右
3. 后续遍历：左右根
```

“序”是围绕根节点的。

![image-20210512160439338](images/image-20210512160439338.png)



![image-20210512160957583](images/image-20210512160957583.png)

![image-20210512160913052](images/image-20210512160913052.png)

![image-20210512160942039](images/image-20210512160942039.png)

## 树的常用操作

树在工作中一般自己单独使用的机会很少。

在刷题过程中，力扣会直接给你树的结构。



## 前缀树

匹配与前缀相同的字符串

复杂度

```
插入: O(N)
搜索: O(N)
前缀(prefix): O(N)
```

## 练习

### [剑指 Offer 26. 树的子结构](https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/5dshwe/)

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

例如:
给定的树 A:

         3
        / \
       4   5
      / \
     1   2给定的树 B：
```
   4 
  /
 1
```

返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。

示例 1：

```
输入：A = [1,2,3], B = [3,1]
输出：false
```

示例 2：

```
输入：A = [3,4,5,1,2], B = [4,1]
输出：true
```

限制：

- `0 <= 节点个数 <= 10000`

题解：

```java
class Solution {
    public boolean isSubStructure(TreeNode A, TreeNode B) {
        return (A != null && B != null) && (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));
    }
    boolean recur(TreeNode A, TreeNode B) {
        if(B == null) return true;
        if(A == null || A.val != B.val) return false;
        return recur(A.left, B.left) && recur(A.right, B.right);
    }
}
```



### 剑指 Offer 55 - I. 二叉树的深度



### LeetCode144前序

### LeetCode144中序

### LeetCode144后序
