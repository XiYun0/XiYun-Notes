# 树

![image-20210512155420871](images/image-20210512155420871.png)

```markdown
节点：除了根节点和叶子节点外的节点
根节点：第一个开始的节点
叶子节点：最底层的节点，没有孩子
```

![image-20210512155523518](images/image-20210512155523518.png)

```markdown
深度：从上往下计算
高度：从下往上计算
层： 从上往下计算。1开始
```

## 二叉树

![image-20210512155805190](images/image-20210512155805190.png)

![image-20210512160157641](images/image-20210512160157641.png)

> 补充：
>
> - 满二叉树叶子节点必须在同一层。
>
> - 满二叉树一定是完全二叉树，但是完成二叉树不一定是满二叉树

二叉树遍历：

```markdown
1. 前序遍历：根左右
2. 中序遍历：左根右
3. 后续遍历：左右根
```

“序”是围绕根节点的。

![image-20210512160439338](images/image-20210512160439338.png)



![image-20210512160957583](images/image-20210512160957583.png)

![image-20210512160913052](images/image-20210512160913052.png)

![image-20210512160942039](images/image-20210512160942039.png)

## 树的常用操作

树在工作中一般自己单独使用的机会很少。

在刷题过程中，力扣会直接给你树的结构。



## 前缀树

匹配与前缀相同的字符串

复杂度

```
插入: O(N)
搜索: O(N)
前缀(prefix): O(N)
```

## 练习

### [剑指 Offer 26. 树的子结构](https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/5dshwe/)

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

例如:
给定的树 A:

         3
        / \
       4   5
      / \
     1   2给定的树 B：
```
   4 
  /
 1
```

返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。

示例 1：

```
输入：A = [1,2,3], B = [3,1]
输出：false
```

示例 2：

```
输入：A = [3,4,5,1,2], B = [4,1]
输出：true
```

限制：

- `0 <= 节点个数 <= 10000`

题解：

> 树的问题肯定用递归解决
>
> 根据条件，A和B一定不能为空

```java
class Solution {
    public boolean isSubStructure(TreeNode A, TreeNode B) {
      	// 递归方法
      	// 根据条件，A和B不为空
      	/**
      		然后分3个情况
      	 return (A != null && B != null) && (情况1 || 情况2 || 情况3);
      	*/
        // 情况1:  A根，B根
      	// 情况2:  A左子树 B
      	// 情况3:  A右子树 B
        return (A != null && B != null) && (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));
    }
    boolean recur(TreeNode A, TreeNode B) {
      // 终止条件
        if(B == null) return true;	// 何时为true
        if(A == null || A.val != B.val) return false;	// 何时为false
        return recur(A.left, B.left) && recur(A.right, B.right);
    }
}
```

### 剑指 Offer 27/LeetCode226. 二叉树的镜像

请完成一个函数，输入一个二叉树，该函数输出它的镜像。

例如输入：

     			4
        /   \
      2     7
     / \   / \
    1   3 6   9

镜像输出：

     			4
        /   \
      7     2
     / \   / \
    9   6 3   1
示例 1：

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```


限制：

`0 <= 节点个数 <= 1000`

注意：本题与主站 226 题相同：https://leetcode-cn.com/problems/invert-binary-tree/

题解：

> 左右子树交换

```java
class Solution {
    public TreeNode mirrorTree(TreeNode root) {
        if(root == null) return null;
      	// 存一下
      /**
      	左右子树交换，和交换值类似，下面这两步会丢失root.left
        root.left = mirrorTree(root.right);
        root.right = mirrorTree(root.left);
      */
        TreeNode tmp = root.left;
        root.left = mirrorTree(root.right);
        root.right = mirrorTree(tmp);
        return root;
    }
}
```

### 剑指 Offer 28/LeetCode101. 对称的二叉树

请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

    		1
       / \
      2   2
     / \ / \
    3  4 4  3

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

    		1
       / \
      2   2
       \   \
       3    3
示例 1：

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

示例 2：

```
输入：root = [1,2,2,null,3,null,3]
输出：false
```


限制：

`0 <= 节点个数 <= 1000`

注意：本题与主站 101 题相同：https://leetcode-cn.com/problems/symmetric-tree/

题解：

> 左节点的左孩子和右节点的右孩子相等
>
> 左节点的右孩子和右节点的左孩子相等

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root == null) return true;	// 如果为空，肯定是对称的
        return dfs(root.left, root.right);
    }

    boolean dfs(TreeNode left, TreeNode right){
        if(left == null && right == null) return true;
        if(left == null || right == null || left.val != right.val) return false;
				
      	// 左节点的左孩子和右节点的右孩子相等,	左节点的右孩子和右节点的左孩子相等
        return dfs(left.right, right.left) && dfs(left.left, right.right);
    }
}
```



### 剑指 Offer 32 - I. 从上到下打印二叉树



### 剑指 Offer 34/LeetCode. 二叉树中和为某一值的路径

输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。

示例:
给定如下二叉树，以及目标和 `target = 22`，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
返回:

```
[
   [5,4,11,2],
   [5,8,4,5]
]
```


提示：

- `节点总数 <= 10000`

注意：本题与主站 113 题相同：https://leetcode-cn.com/problems/path-sum-ii/

题解：

> 前序遍历，根左右
>
> ```
> List<Integer>				单条路径
> List<List<Integer>> 多条路径
> ```

```java
class Solution {
    LinkedList<List<Integer>> res = new LinkedList<>();	// 多条路径
    LinkedList<Integer> path = new LinkedList<>();	// 单条路径
  
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
      // 递归函数
        recur(root, sum);
        return res;
    }
    void recur(TreeNode root, int tar) {
        if(root == null) return;	// 找到叶子节点的下一个
        path.add(root.val);	// 添加当前节点的val
        tar -= root.val;
      	// 如果到了叶子节点（左右子树都为null），并且此时target为0
        if(tar == 0 && root.left == null && root.right == null)
            res.add(new LinkedList(path));
        recur(root.left, tar);	// 根左右，左
        recur(root.right, tar);	// 根左右，右
      
      	// 删除最后一个元素
        path.removeLast();
    }
}
```

### 剑指 Offer 37/LeetCode297. 序列化二叉树

请实现两个函数，分别用来序列化和反序列化二叉树。

示例: 

你可以将以下二叉树：

    		1
       / \
      2   3
         / \
        4   5
    
    序列化为 "[1,2,3,null,null,4,5]"

注意：本题与主站 297 题相同：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/

题解：

```java
```



### 剑指 Offer 55 - I. 二叉树的深度



### LeetCode144.前序

### LeetCode144.中序

### LeetCode144.后序
