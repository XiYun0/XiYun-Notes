# 队列

## 特点

先进先出



## 队列常用操作

### 创建队列

```java
// 使用链表的原因在于，队列都是一边插入一边删除，而这正是链表的优势
Queue<Integer> queue = new LinkedList<>();
```

### 添加元素

```java
queue.add(1);
queue.add(2);
queue.add(3);
```

### 获取元素

```java
int temp1 = queue.peek();
// 1
```

### 删除元素

```java
int temp2 = queue.poll();
```

### 判断队列是否为空

```java
// O(1)
queue.isEmpty();
```

### 队列长度

```java
// O(1)
queue.size();
```

### 遍历队列

```java
// O(1)
while(!queue.isEmpty()){
    int temp = queue.poll();
}
```



## 练习

### 剑指 Offer 59 - II. 队列的最大值

请定义一个队列并实现函数` max_value `得到队列里的最大值，要求函数`max_value`、`push_back` 和` pop_front `的均摊时间复杂度都是O(1)。

若队列为空，`pop_front `和` max_value` 需要返回 -1

示例 1：

```
输入: 
["MaxQueue","push_back","push_back","max_value","pop_front","max_value"]
[[],[1],[2],[],[],[]]
输出: [null,null,null,2,1,2]
```


示例 2：

```
输入: 
["MaxQueue","pop_front","max_value"]
[[],[],[]]
输出: [null,-1,-1]
```


限制：

- 1 <= push_back,pop_front,max_value的总操作数 <= 10000
- 1 <= value <= 10^5

题解：

> 本题使用双端队列和一个普通队列
>
> 类似于min栈那一道，使用了辅助栈

```java
class MaxQueue {
    Queue<Integer> queue;
    Deque<Integer> deque;
    public MaxQueue() {
        queue = new LinkedList<>();
        deque = new LinkedList<>();
    }
    public int max_value() {
        return deque.isEmpty() ? -1 : deque.peekFirst();
    }
  	// 入队列
    public void push_back(int value) {
        queue.offer(value);	// Adds the specified element as the tail (last element) of this list.
        while(!deque.isEmpty() && deque.peekLast() < value)
            deque.pollLast();	// 弹出这个双端队列的末尾元素，the tail of this deque, or null if this deque is empty
        deque.offerLast(value);	// 插入元素到末尾
    }
  
  	// 出队列
    public int pop_front() {
        if(queue.isEmpty()) return -1;
        if(queue.peek().equals(deque.peekFirst()))
            deque.pollFirst();
        return queue.poll();
    }
}
```

